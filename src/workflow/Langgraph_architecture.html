<!DOCTYPE html><html lang="en"><head>

    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Elegant Dynamic Routing in LangGraph</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com"/>
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin=""/>
    <link href="https://fonts.googleapis.com/css2?family=Crimson+Text:ital,wght@0,400;0,600;1,400&amp;family=Inter:wght@300;400;500;600&amp;display=swap" rel="stylesheet"/>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"/>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        :root {
            --ivory: #fefcf8;
            --slate: #475569;
            --muted-slate: #64748b;
            --light-slate: #f1f5f9;
            --accent: #0ea5e9;
            --accent-light: #e0f2fe;
        }

        body {
            background-color: var(--ivory);
            color: var(--slate);
            font-family: 'Inter', sans-serif;
        }

        .serif {
            font-family: 'Crimson Text', serif;
        }

        .hero-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: auto auto;
            gap: 2rem;
            align-items: center;
        }

        .hero-title {
            grid-column: 1 / -1;
            font-size: clamp(2.5rem, 5vw, 4rem);
            line-height: 1.1;
            font-weight: 400;
            font-style: italic;
        }

        .hero-visual {
            position: relative;
            height: 300px;
            border-radius: 12px;
            overflow: hidden;
            background: linear-gradient(135deg, var(--light-slate) 0%, var(--accent-light) 100%);
        }

        .toc-fixed {
            position: fixed;
            left: 2rem;
            top: 50%;
            transform: translateY(-50%);
            width: 280px;
            background: white;
            border-radius: 12px;
            padding: 1.5rem;
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
            border: 1px solid var(--light-slate);
            z-index: 100;
            max-height: 70vh;
            overflow-y: auto;
        }

        .main-content {
            margin-left: 320px;
            max-width: 800px;
        }

        .code-block {
            background: #1e293b;
            color: #e2e8f0;
            padding: 1.5rem;
            border-radius: 8px;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 0.9rem;
            line-height: 1.6;
            overflow-x: auto;
        }

        .citation {
            cursor: pointer;
            color: var(--accent);
            text-decoration: none;
            font-weight: 500;
            transition: all 0.2s ease;
        }

        .citation:hover {
            text-decoration: underline;
            background-color: var(--accent-light);
            padding: 2px 4px;
            border-radius: 4px;
        }

        .section-divider {
            height: 1px;
            background: linear-gradient(90deg, transparent, var(--light-slate), transparent);
            margin: 4rem 0;
        }

        .pull-quote {
            border-left: 4px solid var(--accent);
            padding-left: 2rem;
            margin: 2rem 0;
            font-style: italic;
            font-size: 1.1rem;
            color: var(--muted-slate);
        }

        @media (max-width: 1200px) {
            .toc-fixed {
                position: relative;
                left: 0;
                top: 0;
                transform: none;
                width: 100%;
                margin-bottom: 2rem;
            }
            .main-content {
                margin-left: 0;
                max-width: 100%;
            }
        }

        @media (max-width: 768px) {
            .toc-fixed {
                display: none;
            }
            .hero-grid {
                grid-template-columns: 1fr;
            }
            .hero-visual {
                height: 200px;
            }
        }

        @media (max-width: 480px) {
            .hero-title {
                font-size: 1.8rem;
            }
            .hero-grid {
                gap: 1rem;
            }
            .hero-visual {
                height: 150px;
            }
        }

        .toc-link {
            display: block;
            padding: 0.5rem 0;
            color: var(--muted-slate);
            text-decoration: none;
            border-bottom: 1px solid transparent;
            transition: all 0.2s ease;
        }

        .toc-link:hover, .toc-link.active {
            color: var(--accent);
            border-bottom-color: var(--accent);
        }

        .toc-link.sub {
            padding-left: 1rem;
            font-size: 0.9rem;
        }
    </style>

  </head>

  <body>
    <!-- Fixed Table of Contents -->
    <nav class="toc-fixed">
      <h3 class="serif text-lg font-semibold mb-4 text-slate-800">Contents</h3>
      <a href="#core-concept" class="toc-link">Core Concept</a>
      <a href="#minimalist-approach" class="toc-link">Minimalist Approach</a>
      <a href="#explicit-mapping" class="toc-link">Explicit Mapping</a>
      <a href="#advanced-techniques" class="toc-link">Advanced Techniques</a>
      <a href="#best-practices" class="toc-link">Best Practices</a>
    </nav>

    <!-- Main Content -->
    <main class="main-content px-6 py-12">
      <!-- Hero Section -->
      <section class="mb-16">
        <div class="hero-grid">
          <h1 class="hero-title serif text-slate-900">
            Elegant Dynamic Routing
            <br/>
            <span class="text-blue-600">in LangGraph</span>
          </h1>

          <div class="hero-visual flex items-center justify-center">
            <img src="https://kimi-web-img.moonshot.cn/img/png.pngtree.com/dbb764cf2cc766c3ebfe5748f7c3cf5b8c9ac148.jpg" alt="Abstract visualization of connected nodes in a data flow network" class="w-full h-full object-cover opacity-60" size="large" aspect="wide" query="abstract node network data flow" referrerpolicy="no-referrer" data-modified="1" data-score="0.00"/>
          </div>

          <div class="bg-white p-6 rounded-12 border border-slate-200 shadow-sm">
            <h3 class="serif text-xl font-semibold mb-3 text-slate-800">Key Insights</h3>
            <ul class="space-y-2 text-sm text-slate-600">
              <li class="flex items-center gap-2">
                <i class="fas fa-code text-blue-500"></i>
                Direct return value routing eliminates boilerplate
              </li>
              <li class="flex items-center gap-2">
                <i class="fas fa-map text-blue-500"></i>
                Path maps provide semantic decoupling
              </li>
              <li class="flex items-center gap-2">
                <i class="fas fa-rocket text-blue-500"></i>
                Advanced features enable complex workflows
              </li>
            </ul>
          </div>
        </div>
      </section>

      <!-- Executive Summary -->
      <section class="mb-12 bg-blue-50 p-8 rounded-12 border border-blue-200">
        <h2 class="serif text-2xl font-semibold mb-4 text-slate-800">Executive Summary</h2>
        <p class="text-lg leading-relaxed text-slate-700">
          To minimize boilerplate and create elegant routing in LangGraph, the most direct approach is having your
          <code class="bg-slate-100 px-2 py-1 rounded text-sm">router</code> function return the target node name as a string.
          This eliminates the need for explicit mapping dictionaries, resulting in cleaner, more readable code while maintaining
          full flexibility for complex routing scenarios.
        </p>
      </section>

      <!-- Core Concept Section -->
      <section id="core-concept" class="mb-16">
        <h2 class="serif text-3xl font-semibold mb-8 text-slate-900">Core Concept: Dynamic Routing Foundations</h2>

        <div class="prose prose-lg max-w-none">
          <p class="text-lg leading-relaxed mb-6">
            Dynamic routing serves as the backbone of intelligent, adaptive workflows in LangGraph. Through conditional edges,
            execution paths can dynamically change based on node outputs or graph state, enabling sophisticated agentic systems
            that respond intelligently to diverse inputs and conditions.
          </p>

          <div class="bg-slate-50 p-6 rounded-lg mb-8">
            <h3 class="serif text-xl font-semibold mb-4 text-slate-800">The Router Function Architecture</h3>
            <p class="mb-4">
              The router function acts as the central decision-making component, responsible for inspecting the current
              graph state and determining subsequent execution paths. This function receives the complete state object,
              providing access to user inputs, intermediate results, and any relevant workflow data.
            </p>

            <div class="code-block">
              <pre><code>def router_function(state: State) -&gt; str:
    &#34;&#34;&#34;Inspect state and determine next node&#34;&#34;&#34;
    if state[&#34;user_intent&#34;] == &#34;technical&#34;:
        return &#34;technical_support_node&#34;
    elif state[&#34;user_intent&#34;] == &#34;billing&#34;:
        return &#34;billing_assistant_node&#34;
    else:
        return &#34;general_inquiry_node&#34;</code></pre>
            </div>
          </div>

          <blockquote class="pull-quote">
            &#34;This approach enhances system flexibility while promoting modular design, where different nodes can be
            developed and maintained independently, leading to more robust and scalable applications.&#34;
          </blockquote>
        </div>
      </section>

      <div class="section-divider"></div>

      <!-- Minimalist Approach Section -->
      <section id="minimalist-approach" class="mb-16">
        <h2 class="serif text-3xl font-semibold mb-8 text-slate-900">The Minimalist Approach: Direct Return Value Routing</h2>

        <div class="bg-green-50 p-6 rounded-lg mb-8 border border-green-200">
          <h3 class="serif text-lg font-semibold mb-3 text-green-800">
            <i class="fas fa-leaf mr-2"></i>Recommended Best Practice
          </h3>
          <p class="text-green-700">
            The most elegant and boilerplate-free implementation leverages direct node name return values,
            eliminating the need for explicit path mapping dictionaries.
          </p>
        </div>

        <div class="grid md:grid-cols-2 gap-8 mb-8">
          <div class="bg-white p-6 rounded-lg border border-slate-200 shadow-sm">
            <h4 class="serif text-lg font-semibold mb-4 text-slate-800">Implementation Benefits</h4>
            <ul class="space-y-3 text-slate-600">
              <li class="flex items-start gap-3">
                <i class="fas fa-check-circle text-green-500 mt-1"></i>
                <span>Reduced boilerplate and cleaner code</span>
              </li>
              <li class="flex items-start gap-3">
                <i class="fas fa-check-circle text-green-500 mt-1"></i>
                <span>Improved readability and maintainability</span>
              </li>
              <li class="flex items-start gap-3">
                <i class="fas fa-check-circle text-green-500 mt-1"></i>
                <span>Single source of truth for routing logic</span>
              </li>
              <li class="flex items-start gap-3">
                <i class="fas fa-check-circle text-green-500 mt-1"></i>
                <span>Simplified debugging and tracing</span>
              </li>
            </ul>
          </div>

          <div class="bg-white p-6 rounded-lg border border-slate-200 shadow-sm">
            <h4 class="serif text-lg font-semibold mb-4 text-slate-800">Implementation Pattern</h4>
            <div class="code-block text-sm">
              <pre><code># Direct routing implementation

graph.add_conditional_edges(
&#34;source_node&#34;,
router_function # No path_map required!
)

# Router returns node names directly

def router_function(state: State) -&gt; str:
return state[&#34;target_node&#34;]</code></pre>
</div>
</div>
</div>

        <div class="bg-blue-50 p-6 rounded-lg mb-8">
          <h3 class="serif text-xl font-semibold mb-4 text-slate-800">Complete Minimalist Example</h3>
          <div class="code-block">
            <pre><code>from typing import TypedDict, Literal

class State(TypedDict):
route: Literal[&#34;a&#34;, &#34;b&#34;]

def router_function(state: State) -&gt; Literal[&#34;node_a&#34;, &#34;node_b&#34;]:
&#34;&#34;&#34;Direct node name return&#34;&#34;&#34;
if state[&#34;route&#34;] == &#34;a&#34;:
return &#34;node_a&#34;
else:
return &#34;node_b&#34;

# Graph setup with minimal conditional edge

graph.add_conditional_edges(&#34;classifier&#34;, router_function)</code></pre>
</div>
</div>
</section>

      <div class="section-divider"></div>

      <!-- Explicit Mapping Section -->
      <section id="explicit-mapping" class="mb-16">
        <h2 class="serif text-3xl font-semibold mb-8 text-slate-900">The Explicit Mapping Approach: Using path_map</h2>

        <p class="text-lg leading-relaxed mb-8">
          While direct routing offers elegance, explicit mapping provides valuable decoupling when semantic clarity
          or code organization priorities demand separation between routing logic and node naming conventions.
        </p>

        <div class="grid md:grid-cols-3 gap-6 mb-8">
          <div class="bg-white p-6 rounded-lg border border-slate-200 shadow-sm">
            <div class="w-12 h-12 bg-blue-100 rounded-lg flex items-center justify-center mb-4">
              <i class="fas fa-unlink text-blue-600 text-xl"></i>
            </div>
            <h4 class="serif font-semibold mb-2 text-slate-800">Decoupling</h4>
            <p class="text-sm text-slate-600">Separate routing logic from node naming conventions</p>
          </div>

          <div class="bg-white p-6 rounded-lg border border-slate-200 shadow-sm">
            <div class="w-12 h-12 bg-green-100 rounded-lg flex items-center justify-center mb-4">
              <i class="fas fa-book text-green-600 text-xl"></i>
            </div>
            <h4 class="serif font-semibold mb-2 text-slate-800">Semantic Clarity</h4>
            <p class="text-sm text-slate-600">Use descriptive return values for better readability</p>
          </div>

          <div class="bg-white p-6 rounded-lg border border-slate-200 shadow-sm">
            <div class="w-12 h-12 bg-purple-100 rounded-lg flex items-center justify-center mb-4">
              <i class="fas fa-cogs text-purple-600 text-xl"></i>
            </div>
            <h4 class="serif font-semibold mb-2 text-slate-800">Flexibility</h4>
            <p class="text-sm text-slate-600">Change node names without modifying routing logic</p>
          </div>
        </div>

        <div class="bg-amber-50 p-6 rounded-lg mb-8 border border-amber-200">
          <h3 class="serif text-xl font-semibold mb-4 text-amber-800">Practical Example: Login Flow</h3>
          <div class="code-block">
            <pre><code>from typing_extensions import TypedDict

from langgraph.graph import StateGraph, START, END

class State(TypedDict):
requires_login: bool

def router_function(state: State) -&gt; str:
&#34;&#34;&#34;Semantic return values&#34;&#34;&#34;
if state[&#34;requires_login&#34;]:
return &#34;LOGIN_ASSISTANT&#34; # Semantic, not node name
else:
return &#34;MAIN_APP&#34; # Semantic, not node name

# Path map provides the mapping layer

path_map = {
&#34;LOGIN_ASSISTANT&#34;: &#34;login_assistant_node&#34;,
&#34;MAIN_APP&#34;: &#34;main_app_node&#34;,
}

# Add conditional edge with explicit mapping

builder.add_conditional_edges(&#34;router&#34;, router_function, path_map)</code></pre>
</div>
</div>
</section>

      <div class="section-divider"></div>

      <!-- Advanced Techniques Section -->
      <section id="advanced-techniques" class="mb-16">
        <h2 class="serif text-3xl font-semibold mb-8 text-slate-900">Advanced Techniques and Enhanced Capabilities</h2>

        <div class="space-y-12">
          <div class="bg-white p-8 rounded-lg border border-slate-200 shadow-sm">
            <h3 class="serif text-2xl font-semibold mb-6 text-slate-800">
              <i class="fas fa-shield-alt text-blue-500 mr-3"></i>
              Type Safety with Literal Annotations
            </h3>
            <p class="mb-6 text-slate-700">
              Enhance code robustness and developer experience through Python&#39;s Literal type annotations,
              providing static type checking and improved IDE support.
            </p>

            <div class="code-block mb-6">
              <pre><code>from typing import Literal, TypedDict

class State(TypedDict):
choice: str

def router_function(state: State) -&gt; Literal[&#34;node_a&#34;, &#34;node_b&#34;]:
&#34;&#34;&#34;Statically typed return values&#34;&#34;&#34;
if state[&#34;choice&#34;] == &#34;a&#34;:
return &#34;node_a&#34; # Statically validated
else:
return &#34;node_b&#34; # Statically validated</code></pre>
</div>

            <div class="bg-blue-50 p-4 rounded-lg">
              <h4 class="font-semibold mb-2 text-blue-800">Type Safety Benefits</h4>
              <ul class="text-sm text-blue-700 space-y-1">
                <li>• Early error detection during development</li>
                <li>• Improved IDE code completion and analysis</li>
                <li>• Enhanced graph visualization capabilities</li>
                <li>• Better documentation through type hints</li>
              </ul>
            </div>
          </div>

          <div class="bg-white p-8 rounded-lg border border-slate-200 shadow-sm">
            <h3 class="serif text-2xl font-semibold mb-6 text-slate-800">
              <i class="fas fa-rocket text-green-500 mr-3"></i>
              Dynamic Parallelism with Send API
            </h3>
            <p class="mb-6 text-slate-700">
              Implement sophisticated fan-out patterns and parallel processing workflows using LangGraph&#39;s
              Send API for concurrent node execution.
            </p>

            <div class="code-block mb-6">
              <pre><code>from langgraph.constants import Send

from typing import List

def router_function(state: State) -&gt; List[Send]:
&#34;&#34;&#34;Dynamic parallel execution&#34;&#34;&#34;
chunks = split_data(state[&#34;data&#34;])

    # Fan-out: process chunks in parallel
    return [
        Send(&#34;process_chunk&#34;, chunk)
        for chunk in chunks
    ]

# Map-reduce workflow pattern

graph.add_conditional_edges(
&#34;splitter_node&#34;,
router_function
)</code></pre>
</div>

            <div class="grid md:grid-cols-2 gap-6">
              <div class="bg-green-50 p-4 rounded-lg">
                <h4 class="font-semibold mb-2 text-green-800">Use Cases</h4>
                <ul class="text-sm text-green-700 space-y-1">
                  <li>• Map-reduce data processing</li>
                  <li>• Parallel API calls</li>
                  <li>• Concurrent data validation</li>
                  <li>• Multi-branch decision trees</li>
                </ul>
              </div>
              <div class="bg-purple-50 p-4 rounded-lg">
                <h4 class="font-semibold mb-2 text-purple-800">Performance Benefits</h4>
                <ul class="text-sm text-purple-700 space-y-1">
                  <li>• Reduced processing time</li>
                  <li>• Efficient resource utilization</li>
                  <li>• Scalable workload distribution</li>
                  <li>• Simplified concurrency management</li>
                </ul>
              </div>
            </div>
          </div>

          <div class="bg-white p-8 rounded-lg border border-slate-200 shadow-sm">
            <h3 class="serif text-2xl font-semibold mb-6 text-slate-800">
              <i class="fas fa-box text-purple-500 mr-3"></i>
              Combined Operations with Command Object
            </h3>
            <p class="mb-6 text-slate-700">
              Streamline graph operations by combining state updates and routing decisions in a single
              atomic operation using the Command object pattern.
            </p>

            <div class="code-block mb-6">
              <pre><code>from langgraph.types import Command

def processing_node(state: State):
&#34;&#34;&#34;State update + routing in one operation&#34;&#34;&#34;
processed_data = transform_data(state[&#34;data&#34;])

    return Command(
        update={&#34;processed_data&#34;: processed_data},
        goto=&#34;next_processing_stage&#34;
    )

# Simplified graph structure

graph.add_node(&#34;process_data&#34;, processing_node)
graph.add_edge(&#34;next_processing_stage&#34;, END)</code></pre>
</div>

            <div class="bg-orange-50 p-4 rounded-lg">
              <h4 class="font-semibold mb-2 text-orange-800">When to Use Command Pattern</h4>
              <p class="text-sm text-orange-700">
                Ideal for simple state updates with deterministic routing, reducing graph complexity
                while maintaining clarity. For complex conditional logic, separate router functions
                with conditional edges remain preferable.
              </p>
            </div>
          </div>
        </div>
      </section>

      <div class="section-divider"></div>

      <!-- Best Practices Section -->
      <section id="best-practices" class="mb-16">
        <h2 class="serif text-3xl font-semibold mb-8 text-slate-900">Architectural Best Practices</h2>

        <div class="grid md:grid-cols-2 gap-8 mb-8">
          <div class="space-y-6">
            <div class="bg-green-50 p-6 rounded-lg border border-green-200">
              <h3 class="serif text-lg font-semibold mb-3 text-green-800">
                <i class="fas fa-thumbs-up mr-2"></i>DO
              </h3>
              <ul class="space-y-2 text-sm text-green-700">
                <li>• Use direct return routing for simplicity</li>
                <li>• Implement Literal type annotations</li>
                <li>• Design router functions as pure functions</li>
                <li>• Keep routing logic focused and specific</li>
                <li>• Use path_map for semantic decoupling</li>
              </ul>
            </div>
          </div>

          <div class="space-y-6">
            <div class="bg-red-50 p-6 rounded-lg border border-red-200">
              <h3 class="serif text-lg font-semibold mb-3 text-red-800">
                <i class="fas fa-exclamation-triangle mr-2"></i>AVOID
              </h3>
              <ul class="space-y-2 text-sm text-red-700">
                <li>• Mixing routing logic with node processing</li>
                <li>• Overly complex router functions</li>
                <li>• Hardcoding node names in multiple places</li>
                <li>• Ignoring error handling in routing</li>
                <li>• Creating circular routing dependencies</li>
              </ul>
            </div>
          </div>
        </div>

        <div class="bg-slate-50 p-8 rounded-lg">
          <h3 class="serif text-2xl font-semibold mb-6 text-slate-800">Implementation Decision Framework</h3>

          <div class="overflow-x-auto">
            <table class="w-full text-sm">
              <thead>
                <tr class="border-b border-slate-200">
                  <th class="text-left py-3 px-4 font-semibold text-slate-800">Scenario</th>
                  <th class="text-left py-3 px-4 font-semibold text-slate-800">Recommended Approach</th>
                  <th class="text-left py-3 px-4 font-semibold text-slate-800">Complexity</th>
                </tr>
              </thead>
              <tbody class="divide-y divide-slate-200">
                <tr>
                  <td class="py-3 px-4">Simple conditional routing</td>
                  <td class="py-3 px-4 text-blue-600">Direct return value</td>
                  <td class="py-3 px-4"><span class="bg-green-100 text-green-800 px-2 py-1 rounded">Low</span></td>
                </tr>
                <tr>
                  <td class="py-3 px-4">Semantic decoupling needed</td>
                  <td class="py-3 px-4 text-purple-600">path_map with descriptive keys</td>
                  <td class="py-3 px-4"><span class="bg-yellow-100 text-yellow-800 px-2 py-1 rounded">Medium</span></td>
                </tr>
                <tr>
                  <td class="py-3 px-4">Parallel processing</td>
                  <td class="py-3 px-4 text-green-600">Send API with list return</td>
                  <td class="py-3 px-4"><span class="bg-orange-100 text-orange-800 px-2 py-1 rounded">High</span></td>
                </tr>
                <tr>
                  <td class="py-3 px-4">State update + routing</td>
                  <td class="py-3 px-4 text-indigo-600">Command object pattern</td>
                  <td class="py-3 px-4"><span class="bg-yellow-100 text-yellow-800 px-2 py-1 rounded">Medium</span></td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>
      </section>

      <!-- Conclusion -->
      <section class="mb-16">
        <div class="bg-gradient-to-r from-blue-50 to-indigo-50 p-8 rounded-lg border border-blue-200">
          <h2 class="serif text-2xl font-semibold mb-4 text-slate-800">Conclusion</h2>
          <p class="text-lg leading-relaxed text-slate-700 mb-4">
            LangGraph&#39;s dynamic routing capabilities provide a powerful foundation for building intelligent,
            adaptive workflows. By understanding the trade-offs between direct return routing and explicit
            mapping approaches, developers can create elegant, maintainable solutions that scale with
            application complexity.
          </p>
          <p class="text-slate-600">
            The key lies in selecting the right approach for each scenario: minimalist direct routing for
            simplicity and clarity, explicit mapping for semantic decoupling, and advanced patterns like
            Command objects and Send API for sophisticated workflow requirements.
          </p>
        </div>
      </section>

      <!-- Citations -->
      <section class="text-sm text-slate-500 border-t border-slate-200 pt-8">
        <h3 class="serif text-lg font-semibold mb-4 text-slate-700">References</h3>
        <div class="grid md:grid-cols-2 gap-4">
          <div>
            <p class="mb-2">
              <a href="https://langchain-ai.github.io/langgraph/concepts/low_level/" class="citation" target="_blank">
                [539] LangGraph Low-Level Concepts
              </a>
            </p>
            <p class="mb-2">
              <a href="https://www.baihezi.com/mirrors/langgraph/tutorials/introduction/index.html" class="citation" target="_blank">
                [534] LangGraph Introduction Tutorial
              </a>
            </p>
            <p class="mb-2">
              <a href="https://medium.com/@vamsikd219/beginners-guide-to-langgraph-create-a-multi-agent-assistant-with-llama-3-ab51c8acd0a1" class="citation" target="_blank">
                [464] Beginner&#39;s Guide to LangGraph
              </a>
            </p>
          </div>
          <div>
            <p class="mb-2">
              <a href="https://langchain-ai.github.io/langgraph/concepts/low_level/" class="citation" target="_blank">
                [457] LangGraph Low-Level API
              </a>
            </p>
            <p class="mb-2">
              <a href="https://duplocloud.com/langchain-vs-langgraph/" class="citation" target="_blank">
                [568] LangChain vs LangGraph Comparison
              </a>
            </p>
            <p class="mb-2">
              <a href="https://medium.com/@gopiariv/langgraph-a-beginners-guide-to-building-ai-workflows-e500965f2ef9" class="citation" target="_blank">
                [538] LangGraph AI Workflows Guide
              </a>
            </p>
          </div>
        </div>
      </section>
    </main>

    <script>
        // Smooth scrolling for anchor links
        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', function (e) {
                e.preventDefault();
                const target = document.querySelector(this.getAttribute('href'));
                if (target) {
                    target.scrollIntoView({
                        behavior: 'smooth',
                        block: 'start'
                    });
                }
            });
        });

        // Active section highlighting in TOC
        const sections = document.querySelectorAll('section[id]');
        const tocLinks = document.querySelectorAll('.toc-link');

        function updateActiveTocLink() {
            let currentSection = '';

            sections.forEach(section => {
                const rect = section.getBoundingClientRect();
                if (rect.top <= 100 && rect.bottom >= 100) {
                    currentSection = section.id;
                }
            });

            tocLinks.forEach(link => {
                link.classList.remove('active');
                if (link.getAttribute('href') === `#${currentSection}`) {
                    link.classList.add('active');
                }
            });
        }

        window.addEventListener('scroll', updateActiveTocLink);
        updateActiveTocLink(); // Initial call
    </script>

</body></html>

